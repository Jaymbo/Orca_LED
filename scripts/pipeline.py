import os
import glob
import logging
import time
from pathlib import Path
import subprocess
from openbabel import openbabel
from database import Database
import sys
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from xbpy.rdutil.io import read_molecules
from rdkit.Chem.rdmolops import GetFormalCharge, GetMolFrags
from rdkit.Chem.rdmolfiles import MolToXYZBlock
from rdkit import Chem
import numpy as np
import math

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def track_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        elapsed_time = end_time - start_time
        logging.info(f"Function '{func.__name__}' took {elapsed_time:.4f} seconds to complete.")
        return result
    return wrapper

class XYZFileHandler:
    def __init__(self, input_xyz: str) -> None:
        self.input_xyz: str = input_xyz
        self.atom_count: int
        self.atom_data: list[str]
        self.atom_count, self.atom_data = self.read_xyz_file()

    @track_time
    def read_xyz_file(self) -> tuple[int, list[str]]:
        with open(self.input_xyz, "r") as xyz_file:
            lines = xyz_file.readlines()
        atom_count = int(lines[0].strip())
        atom_data = [line.replace("\t", " ") for line in lines[2:2 + atom_count]]
        return atom_count, atom_data

    def write_fragment_xyz(self, fragment_atoms: list[str], output_filename: str) -> None:
        header = f"{len(fragment_atoms)}\nFragment generated by split_xyz\n"
        with open(output_filename, 'w') as output_file:
            output_file.write(header)
            output_file.writelines(fragment_atoms)

    def split_xyz(self, fragments_list: list[list[int]], output_prefix: str, name="fragment") -> None:
        for i, fragment_indices in enumerate(fragments_list):
            fragment_atoms = [self.atom_data[idx] for idx in fragment_indices]
            output_filename = f"{output_prefix}/{name}_{i + 1:03}.xyz"
            self.write_fragment_xyz(fragment_atoms, output_filename)


class Mol2FileHandler:
    def __init__(self, input_mol2: str) -> None:
        self.input_mol2 = input_mol2

    @track_time
    def convert_mol2_to_xyz(self, output_xyz: str) -> None:
        logging.info(f"Converting MOL2 file to XYZ: {self.input_mol2} -> {output_xyz}")
        ob_conversion = openbabel.OBConversion()
        ob_conversion.SetInAndOutFormats("mol2", "xyz")
        mol = openbabel.OBMol()
        if not ob_conversion.ReadFile(mol, self.input_mol2):
            logging.error(f"Error reading file: {self.input_mol2}")
            raise ValueError(f"Error reading file: {self.input_mol2}")
        if not ob_conversion.WriteFile(mol, output_xyz):
            logging.error(f"Error writing file: {output_xyz}")
            raise ValueError(f"Error writing file: {output_xyz}")


class ORCAInputFileCreator:
    def __init__(self, file: str, header_in=None) -> None:
        self.file: str = file
        self.mols: dict[Mol] = {}
        self.header: str = header_in or """! DLPNO-CCSD(T) def2-svp def2-svp/C DEF2/J RIJCOSX veryTIGHTSCF TIGHTPNO LED

%mdci DoDIDplot true end

%maxcore 160000

%mdci
  MaxIter 200
end"""
        self.header += """\n%pal \n  nprocs """
        self.xyz_file: str = self.file.replace(".mol2", ".xyz") if self.file.endswith(".mol2") else self.file
        self.xyz_folder: str = os.path.dirname(self.xyz_file)
        os.makedirs(self.xyz_folder, exist_ok=True)
        self.frag_len: list[int] = []
        self.mem: list[int] = []
        self.nprocs: list[int] = []
        self.scratch: list[int] = []

    def create_inp_file_content(self, charge: int, npros: int, xyz_file: str, fragment_lines: list[str]) -> str:
        inp_content = f"{self.header}{npros}\nend\n*XYZfile {charge} 1 {xyz_file}\n\n"
        inp_content += "".join(fragment_lines)
        return inp_content

    def fragment_cleaning(self, xyz_file: str, fragment_groups: list[list[int]]) -> list[list[int]]:
        """
        sortiert fragmente so das elemente mit doppelten buchstaben in den einstellungen fragmenten ist
        """

        atom_names = []
        with open(xyz_file, "r") as file:
            lines = file.readlines()[2:]
            atom_names = [line.split()[0] for line in lines]

        for i, atom in enumerate(atom_names):
            if len(atom) > 1:
                for j, fragment in enumerate(fragment_groups):
                    for atom in fragment:
                        if atom == i:
                            fragment_groups.insert(0, fragment_groups.pop(j))
                            break
        return fragment_groups
    
    @track_time
    def create_inp_files(self, file_cache) -> None:
        if self.file.endswith(".mol2"):
            Mol2FileHandler(self.file).convert_mol2_to_xyz(self.xyz_file)
        self.mols[self.xyz_file] = Mol(self.xyz_file, self.mols)
        self.fragments = self.mols[self.xyz_file].get_fragments()

        fragment_lines = self.handle_fragments()

        xyz_files = sorted(glob.glob(os.path.join(self.xyz_folder, "*.xyz")))
        # alle die mit subsys anfangen sortieren alle andetren aussortieren
        xyz_files = [file for file in xyz_files if "subsys_" in file]
        xyz_files.append(self.xyz_file)
        if not xyz_files:
            return
        for i, xyz_file_i in enumerate(xyz_files):
            mol = self.mols[xyz_file_i]
            self.create_single_inp_file(mol, xyz_file_i, Path(xyz_file_i).parent, self.nprocs[i], fragment_lines[i])
            path = Database.process_candidate(Path(xyz_file_i.split(".")[0]), file_cache)
            if path:
                self.create_single_inp_file(mol, path, Path(path).parents[1], self.nprocs[i], fragment_lines[i])
                sh_path = ShellScriptCreator.single_sh_script_erstellen(path, Path(path).parents[1], i, self.nprocs[i], self.frag_len[i], self.mem[i])
                # subprocess.run(["sbatch", sh_path])

    def handle_fragments(self) -> list[str]:
        subsys_groups = self.parse_fragments(self.fragments)
        self.calculate_frag_len(subsys_groups)
        for fragment_groups in subsys_groups:
            fragment_groups = self.fragment_cleaning(self.xyz_file, fragment_groups)

            xyz_handler = XYZFileHandler(self.xyz_file)
        frag_list = []
        for groups in subsys_groups[:-1]:
            group_list = []
            for group in groups:
                group_list.extend(group)
            frag_list.append(group_list)
        xyz_handler.split_xyz(subsys_groups[-1], self.xyz_folder)
        xyz_handler.split_xyz(frag_list, self.xyz_folder, name="subsys")


        fragment_lines = [self.create_fragment_lines(groups) for groups in subsys_groups]
        return fragment_lines

    @track_time
    def parse_fragments(self, fragments: str) -> list[list]:
        subsys_groups = []
        supersys = []
        for subsys in fragments.split("#"):
            fragment_groups = []
            for fragment in subsys.split(","):
                fragment_indices = []
                for part in fragment.split():
                    if "-" in part:
                        start, end = map(int, part.split("-"))
                        fragment_indices.extend(range(start-1, end))
                    else:
                        fragment_indices.append(int(part)-1)
                fragment_groups.append(fragment_indices)
            if fragment_groups:
                subsys_groups.append(fragment_groups)
                supersys.extend(fragment_groups)
        subsys_groups.append(supersys)
        return subsys_groups

    @track_time
    def create_fragment_lines(self, fragment_groups: list[list[int]]) -> list[str]:
        logging.info("Creating fragment lines")
        fragment_lines = ["%geom\n Fragments\n"]
        all = []
        for group in fragment_groups:
            all.extend(group)
        all_sorted = sorted(all)
        index_mapping = {old_index: new_index for new_index, old_index in enumerate(all_sorted)}
        for i, group in enumerate(fragment_groups, start=1):
            group = [index_mapping[old_index] for old_index in group]
            fragment_atoms = " ".join(map(str, group))
            fragment_lines.append(f"  {i} {{{fragment_atoms}}} end\n")
        fragment_lines.append(" end\nend\n")
        return fragment_lines

    def create_single_inp_file(self, mol, xyz_file_i: str, base: Path, npros: int, fragment_line: str) -> Path:
        logging.info(f"Creating single ORCA input file for: {xyz_file_i}")
        charge = mol.get_charge()
        inp_content = self.create_inp_file_content(charge, npros, xyz_file_i, fragment_line)
        base_name = os.path.splitext(os.path.basename(xyz_file_i))[0]
        base_path = base / base_name
        inp_path = base_path / f"{base_name}.inp"
        os.makedirs(base_path, exist_ok=True)
        
        with open(inp_path, 'w') as inp_file:
            inp_file.write(inp_content)
        
        return inp_path

    def calculate_frag_len(self, subsys_groups: list[list]) -> None:
        npros_options = [48, 24, 12, 8, 6, 4, 2, 1]
        mem_options = [180, 370, 750, 1500]

        for fragments_group in subsys_groups:
            frag_len = sum(len(group) for group in fragments_group)
            self.frag_len.append(frag_len)

            best_mem = None
            best_nprocs = None
            found = False
            for nprocs in npros_options:
                if found:
                    break
                for mem in mem_options:
                    estimated_mem = frag_len * nprocs * 0.6
                    mem_diff = mem - estimated_mem
                    # print(f"frag_len: {frag_len}, nprocs: {nprocs}, mem: {mem}, estimated_mem: {estimated_mem}, mem_diff: {mem_diff}")
                    if 0 <= mem_diff:
                        found = True
                        best_mem = mem
                        best_nprocs = nprocs
                        break	
            if not found:
                logging.warning(f"No suitable memory/nprocs found for frag_len {frag_len}. Using max memory and min nprocs.")
            self.mem.append(best_mem or mem_options[-1])  # Fallback to max memory if no match
            self.nprocs.append(best_nprocs or npros_options[-1])  # Fallback to min nprocs if no match

class ShellScriptCreator:
    def __init__(self, mem: int, nprocs: int, time: str, path: str, name: str, base: Path) -> None:
        self.mem = mem
        self.nprocs = nprocs
        self.time = time
        self.path = path.split(".")[0]
        self.name = name
        self.base = base
        self.scratch = 6000 if self.mem == 1500 else 2900 if self.mem == 750 else 0

    @track_time
    def create_sh_script_content(self) -> str:
        script_content = f"""#!/bin/bash
#SBATCH --nodes=1
#SBATCH --mem={self.mem}gb
#SBATCH --ntasks-per-node={self.nprocs}
#SBATCH --time={self.time}
{f"#SBATCH --gres=scratch:{self.scratch}" if self.scratch != 0 else ""}
#SBATCH --output={self.path}_out.out
#SBATCH --error={self.path}_err.err

name={self.name}

workspace_directory={self.base}
orca=/opt/bwhpc/common/chem/orca/6.0.1_shared_openmpi-4.1.6_avx2/orca

echo $name
module load chem/orca/6.0.1
module load mpi/openmpi/4.1
module list
{'cp $workspace_directory/$name/$name.inp $SCRATCH' if self.scratch != 0 else ''}
{'cd $SCRATCH' if self.scratch != 0 else ''}
echo "ausführen"
$orca {'$workspace_directory/$name/$name.inp' if self.scratch == 0 else '$SCRATCH/$name.inp'} > $workspace_directory/$name/$name.out
{'cp $SCRATCH/* $workspace_directory/$name' if self.scratch != 0 else ''}
"""
        return script_content

    @staticmethod
    def single_sh_script_erstellen(path: str, base: Path, i: int, npros: int, frag_len: int, mem: int) -> Path:
        name = Path(path).stem
        total_path = base / f"{name}/{name}.sh"
        script_content = ShellScriptCreator(
            mem, npros, f"{math.floor(0.12*frag_len)}:{int((0.12*frag_len * 60) % 60):02}:00", path, name, base
        ).create_sh_script_content()
        with open(total_path, "w") as file:
            file.write(script_content)
        return total_path

class Mol:
    def __init__(self, filename: str, mols: dict = {}):
        self.mols: dict = mols
        self.filename: str = filename
        self.mols[self.filename] = self
        self.mol = None
        self.charge: int = None
        self.fragments: str = None
        if filename in self.mols:
            return

    def read_mol(self):
        mol = read_molecules(self.filename)
        self.mol = next(mol)

    def get_charge(self) -> int:
        if self.mol is None:
            self.read_mol()
        self.charge = GetFormalCharge(self.mol)
        return self.charge
    
    def get_fragments(self) -> str:
        if self.fragments is not None:
            return self.fragments
        if self.mol is None:
            self.read_mol()
        mol_block = MolToXYZBlock(self.mol).strip().split('\n')[2:]
        coords = np.mean([np.array(atom.split()[1:], dtype=float) for atom in mol_block], axis=0)
        distances = [np.linalg.norm(np.array(atom.split()[1:], dtype=float) - coords) for atom in mol_block]
        closest_atom = np.argmin(distances) + 1

        frags = [list(frag) for frag in GetMolFrags(self.mol, sanitizeFrags=False, asMols=False)]
        mols = [mol for mol in GetMolFrags(self.mol, sanitizeFrags=False, asMols=True)]
        closest_frag_index = next(i for i, frag in enumerate(frags) if closest_atom in frag)
        frags.insert(0, frags.pop(closest_frag_index))
        mols.insert(0, mols.pop(closest_frag_index))

        ligand_mol = mols[0]
        combined_mol = mols[1]
        for mol in mols[2:]:
            combined_mol = Chem.CombineMols(combined_mol, mol)
        
        ligand_path = Path(self.filename).parent / "subsys_001.xyz"
        self.mols[str(ligand_path)] = Mol(ligand_path, self.mols)
        self.mols[str(ligand_path)].mol = ligand_mol

        combined_path = Path(self.filename).parent / "subsys_002.xyz"
        self.mols[str(combined_path)] = Mol(combined_path, self.mols)
        self.mols[str(combined_path)].mol = combined_mol

        frag_str = ",".join(" ".join(str(atom + 1) for atom in frag) for frag in frags)
        frag_str = frag_str.replace(",", "#", 1)
        self.fragments = frag_str
        return self.fragments
