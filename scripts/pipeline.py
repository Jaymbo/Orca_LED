import os
import glob
import re
import subprocess
from openbabel import openbabel


def calculate_charge(file_path):
    """
    Berechnet die Ladung basierend auf den definierten Regeln für H, C, N und Cl.
    Berechnet das Ergebnis mod 8 und passt es an die nächstgelegene Ladung an.
    """
    # Ladungswerte für jedes Atom
    charge_map = {
        "H": 1,
        "C": -4,
        "N": -3,
        "O": -2,
        "Cl": -1,
        "S": -4,
        "Br": -1,
        "P": -3,
        "Se": -2,
        "F": -1
    }

    # Initiale Ladung
    total_charge = 0

    # Regulärer Ausdruck zur Extraktion der Atomsymbole und Koordinaten
    pattern = re.compile(r"([A-Z][a-z]?)\s+([-+]?\d*\.\d+)\s+([-+]?\d*\.\d+)\s+([-+]?\d*\.\d+)")
    
    # Datei einlesen und Zeilen analysieren
    with open(file_path, "r") as file:
        for line in file:
            match = pattern.match(line)
            if match:
                atom = match.group(1)
                if atom in charge_map:
                    total_charge += charge_map[atom]
                else:
                    print(f"Atom missing in list: {atom}")
                    break

    # Ergebnis mod 8 berechnen
    charge_mod_8 = total_charge % 8

    # Nächstgelegene Anpassung der Ladung
    if charge_mod_8 == 7:
        adjusted_charge =  - 1
    elif charge_mod_8 == 6:
        adjusted_charge =  - 2
    elif charge_mod_8 == 5:
        adjusted_charge =  + 3
    elif charge_mod_8 == 4:
        adjusted_charge =  + 4
    elif charge_mod_8 == 3:
        adjusted_charge =  - 3
    elif charge_mod_8 == 2:
        adjusted_charge =  - 2
    elif charge_mod_8 == 1:
        adjusted_charge =  - 1
    else:
        adjusted_charge = 0

    # Ergebnisse ausgeben
    return adjusted_charge


def split_xyz(input_xyz, fragments_list, output_prefix):
    """
    Splits a .xyz file into separate files based on fragment definitions.

    Args:
        input_xyz (str): Path to the input .xyz file.
        fragments (str): String with mixed ranges and individual atoms, e.g., "1-12,13 15 17,18-25 14 16".
        output_prefix (str): Prefix for the output .xyz files.
    """
    # Read the .xyz file
    with open(input_xyz, "r") as xyz_file:
        lines = xyz_file.readlines()

    # Extract atom count and skip the first two header lines
    atom_count = int(lines[0].strip())
    atom_data = lines[2:2 + atom_count]
    atom_data = [atom.replace("\t", " ") for atom in atom_data]
    # Create separate .xyz files for each fragment
    for i, fragment_indices in enumerate(fragments_list):
        fragment_atoms = [atom_data[idx - 1] for idx in fragment_indices]  # Convert to 0-based index

        if i + 1 < 10:
            output_filename = f"{output_prefix}/fragment_00{i + 1}.xyz"
        elif i+1 < 100:	
            output_filename = f"{output_prefix}/fragment_0{i + 1}.xyz"
        else:
            output_filename = f"{output_prefix}/fragment_{i + 1}.xyz"
        with open(output_filename, "w") as output_file:
            output_file.write(f"{len(fragment_atoms)}\n")
            output_file.write("Fragment generated by split_xyz\n")
            output_file.writelines(fragment_atoms)


def mol2_to_xyz(input_mol2, output_xyz):
    """
    Konvertiert eine .mol2-Datei in eine .xyz-Datei und erstellt eine .inp-Datei basierend auf den Gruppeninformationen.
    """
    ob_conversion = openbabel.OBConversion()
    ob_conversion.SetInAndOutFormats("mol2", "xyz")

    mol = openbabel.OBMol()
    if not ob_conversion.ReadFile(mol, input_mol2):
        raise ValueError(f"Fehler beim Lesen der Datei: {input_mol2}")
    if not ob_conversion.WriteFile(mol, output_xyz):
        raise ValueError(f"Fehler beim Schreiben der Datei: {output_xyz}")

    # Gruppeninformationen aus der .mol2-Datei extrahieren
    fragments = []
    with open(input_mol2, "r") as mol2_file:
        inside_atoms = False
        for line in mol2_file:
            if line.startswith("@<TRIPOS>ATOM"):
                inside_atoms = True
            elif line.startswith("@<TRIPOS>BOND"):
                inside_atoms = False
            elif inside_atoms:
                parts = line.split()
                # /t ersetzen durch Leerzeichen
                parts = [part.replace("/t", " ") for part in parts]
                if len(parts) > 7:  # Annahme: Gruppennummer steht an der 8. Position
                    fragments.append(parts[7])

    # Fragmentzuweisung erstellen
    fragment_assignments = {}
    for idx, group in enumerate(fragments):
        if group not in fragment_assignments:
            fragment_assignments[group] = []
        fragment_assignments[group].append(idx)
    # dic in liste umwandeln
    return fragment_assignments


def create_inp_files(file, fragments = None):
    """
    Erstellt .inp-Dateien für alle .xyz-Dateien in einem Ordner basierend auf einer Fragmentierungsangabe.
    Args:
        xyz_folder (str): Ordnerpfad mit .xyz-Dateien.
        fragments (str): Fragmentierungsangabe, z.B. "1-12,13-24,...".
        header (str): Optionaler Header für die .inp-Dateien. Wenn None, wird ein Standardheader verwendet.
    """
    # Standardheader, falls keiner angegeben ist
    header = ["""! DLPNO-CCSD(T) def2-svp def2-svp/C DEF2/J RIJCOSX TIGHTSCF normalPNO LED

%pal 
  nprocs ""","""
end

%mdci DoDIDplot true end

%maxcore 2000

%mdci
  MaxIter 200
end

"""]
    # wenn file .mol2 ist dann zu .xyz konvertieren
    if file.endswith(".mol2"):
        extr_frag = mol2_to_xyz(file, file.replace(".mol2", ".xyz"))
        xyz_file = file.replace(".mol2", ".xyz")
    else:
        xyz_file = file
    

    xyz_folder = os.path.dirname(xyz_file)

    # Stelle sicher, dass der Zielordner existiert
    inp_folder = xyz_folder
    os.makedirs(inp_folder, exist_ok=True)

    # Suche nach allen .xyz-Dateien im Ordner
    
    if fragments is None:
        fragment_groups = extr_frag.values()
    else:
        # Fragmentierungsangabe verarbeiten
        fragment_groups = []
        for fragment in fragments.split(","):
            fragment_indices = []
            for part in fragment.split():
                if "-" in part:
                    start, end = map(int, part.split("-"))
                    fragment_indices.extend(range(start, end + 1))
                else:
                    fragment_indices.append(int(part))
            fragment_groups.append(fragment_indices)
    # fragments len von den einzelnen fragmentgruppen, wenn unter 48 dann die lenge ansonsten 48
    frag_len = []
    for i, group in enumerate(fragment_groups, start=1):
        if len(group) < 48:
            frag_len.append(len(group))
        else:
            frag_len.append(48)
    
    split_xyz(xyz_file, fragment_groups, xyz_folder)
    xyz_files = glob.glob(os.path.join(xyz_folder, "*.xyz"))
    if not xyz_files:
        print("Keine .xyz-Dateien im angegebenen Ordner gefunden.")
        return
    # xyzfiles nach namen sortieren
    xyz_files.sort()



    # Wenn es sich um die Datei handelt, die alle Fragmente enthält, füge Fragmentierung hinzu
    fragment_lines = ["%geom\n Fragments\n"]
    for i, group in enumerate(fragment_groups, start=1):
        fragment_atoms = " ".join(map(str, group))
        fragment_lines.append(f"  {i} {{{fragment_atoms}}} end\n")
    fragment_lines.append(" end\nend\n")
    # .inp-Dateien erstellen
    inp_paths = []
    for i in range(len(xyz_files)):
        xyz_file_i = xyz_files[i]
        base_name = os.path.splitext(os.path.basename(xyz_file_i))[0]
        charge = calculate_charge(xyz_file_i)  # Ladung berechnen

        # .inp-Datei zusammenbauen
        if os.path.basename(xyz_file).split(".")[0] == os.path.basename(xyz_file_i).split(".")[0]:
            sum_atoms = sum(frag_len)
            if sum_atoms > 48:
                sum_atoms = 48
            # sum atoms hinzufügen in frag_lenm an der aktuellen stelle statt i
            frag_len = frag_len[:i] + [sum_atoms] + frag_len[i:]
            inp_content = f"{header[0]}{frag_len[i]}{header[1]}\n*XYZfile {charge} 1 {xyz_file_i}\n\n" + "\n"
            inp_content = inp_content + str("".join(fragment_lines))
        else:
            inp_content = f"{header[0]}{frag_len[i]}{header[1]}\n*XYZfile {charge} 1 {xyz_file_i}\n\n" + "\n"
        # ordner erstellen
        os.makedirs(os.path.join(inp_folder, base_name), exist_ok=True)
        inp_paths.append(os.path.join(inp_folder, f"{base_name}/{base_name}.inp"))

        # .inp-Datei speichern
        with open(inp_paths[-1], "w") as inp_file:
            inp_file.write(inp_content)
    return inp_paths, os.path.dirname(xyz_file), frag_len


# Beispielaufruf
# TODO .xyz with fragments (bsp.: "10-14,13 12 17 23-27, 1 3 5") or .mol2 without fragments (automatic fragmentation in aminoacids) needs full path with multithreading
# 3wth:"208-234,1-3,4-25,26-47,48-69,70-87,88-94,95-110,111-116,117-140,141-153,154-172,173-180,181-188,189-207"
# paths, base, frag_len = create_inp_files("/lustre/work/ws/ws1/tu_zxofv28-my_workspace/Paper1_LED/Paper1.xyz", "337-349,1-6,7-26,27-32,33-38,39-54,55-60,61-66,67-76,77-83,84-105,106-111,112-117,118-132,133-138,139-144,145-160,161-166,167-172,173-192,193-202,203-219,220-238,239-244,245-250,251-264,265-271,272-290,291-296,297-302,303-318,319-330,331-336,350-352,353-355,356-358,359-361,362-364,365-367,368-370,371-373")
paths, base, frag_len = create_inp_files("/lustre/work/ws/ws1/tu_zxofv28-my_workspace/Paper3_LED/Paper3.xyz", "215-231,7-22,23-41,42-47,48-53,54-60,61-66,67-72,73-94,95-113,114-130,131-136,137-142,143-164,165-170,171-176,177-195,196-201,202-214,232-234,235-237,238-240,241-243,244-246,247-249")

for i in range(len(paths)):
    path = paths[i]
    name = os.path.basename(path).split(".")[0]
    subprocess.run(["sbatch", "/lustre/work/ws/ws1/tu_zxofv28-my_workspace/scripts/start_local.sh", base, name])
